### Hello 计组

计算机组成原理研究的是计算机硬件在底层如何协调工作的。

计算机硬件：CPU型号-性能、运行内存、机身存储、显卡等。

计算机硬件能识别的数据：0101二进制数，用高低电平分别表示1/0。

高电平、低电平：电压比较低的情况为低电平，电压叫高的情况为高电平。可以通过电信号传递数据。

CPU、内存条针脚用了传递电信号的。主板上的印刷电路是硬件直接交换数据的通道，很多条线路可以传递多个二进制数位，每个二进制数称为1bit。

数字、文字、图像如何用二进制表示？

CPU如何对二进制数进行加减乘除？

如何存储这些二进制数？

如何从内存中取出想要的数据？

CPU如何识别和执行我们写的程序？

...............

### 计算机的发展

##### 什么是计算机系统

<span style="color:red">计算机系统</span> = 硬件 + 软件

硬件：计算机的实体部分（主机、外设），是计算机系统的物理基础，决定了计算机的天花板、瓶颈。

软件：具有各类特殊功能的程序组成（操作系统、各种application），决定了把硬件的性能发挥到什么程度。

计算机系统的好坏取决于软硬件功能总和。

软件--系统软件（用来管理整个计算机系统）、应用软件（按任务需要编制成各种程序）

系统软件：操作系统、数据库管理系统、标准程序库、网络软件、语言处理程序、服务程序

应用软件：各种application

##### 硬件的发展

1946第一台电子数字计算机（ENIAC）-- 冯诺伊曼，对应逻辑元件电子管。逻辑元件：用来处理电信号的最小的基本单元。1.8W个电子管。体积超大、耗电量大、运算速度慢、使用机器语言编程编程。

贝尔实验室发明晶体管--计算机逻辑元件，体积减小、功耗降低、使用晶体管能设计更复杂的计算线路，因此计算速度加快。出现高级编程语言FORTRAIN，有了操作系统雏形。

中小规模集成电路--将元件集成在基片上，计算机变得越来越小，功耗更低，集成电路可靠性比晶体管手动焊接的可靠性高很多。这阶段计算机主要用于科学计算等专业用途，高级语言迅速发展，开始有了分时操作系统。

大规模、超大规模集成电路（1972-now）--随着科学工艺的不断提升，此时开始出现微处理器（CPU）、微型计算机、个人计算机（PC）开始萌芽。操作系统：Windows、MacOS、Lunix

苹果A13处理器工艺7nm:(每个元件宽度7nm，每个CPU集成了85个晶体管)

微处理器发展：代表Intel 。机器字长：计算机<span style="color:red">一次</span> 整数运算所能处理的二进制位数。微型计算机的发展以微处理器技术为标志。

1947年，贝尔实验室(三个人)，发明了“晶体管” -->  

1955年，肖克利在硅谷创建肖克利实验室股份有限公司 --> 

1957年，八叛徒（traitorous eight）创立仙童、半导体公司 --> 

1959年，仙童半导体公司发明了“集成电路”  --> 

1968年，摩尔等人（三个人）离开仙童，创立Intel --> 

1969年，仙童销售部负责人桑德斯离开仙童，创立AMD -->

晶体管之父--威廉·肖克利 --> 摩尔、罗伯茨、克莱纳、偌伊斯、格里尼克、布兰克、赫尔尼、拉斯特

Intel、AMD是后来超大规模集成电路的推行者

摩尔定律：在集成电路上可以容纳的晶体管数目，约每隔18个月增加一倍，整体性能提升一倍。

主存的发展也符合摩尔定律 -- 每隔两年。1970年，仙童公司生产了世界上第一个较大容量的半导体存储器。

##### 软件的发展

所有的软件都是用编程语言编写出来的

机器语言、汇编语言（软件发展的初期，机器语言可读性很差，于是人们发明了汇编语言）--> FORTRAN -->PASCAL --> C++ --> JAVA / Python 用于网络环境的编程语言。

FORTRAN、PASCAL、C++ 为高级语言 ...

操作系统系统类的软件也在不断的发展：DOS系统 --> Windows --> Android --> IOS

##### 目前的发展趋势

"两极"分化：

一极是微型计算机更微型化、网络化、高性能、多用途方向发展

另一极是朝着巨型计算机向更巨型化、超高速、并行处理、智能化方向发展 -- 神威·太湖之光（9.3亿亿次/s浮点运算）



### 计算机硬件基本组成

##### 冯诺伊曼结构

早期冯诺伊曼结构

ENIAC（手动接线来控制计算）--> 冯诺伊曼提出<span style="color:red">存储程序</span> 的概念 --> 世界上第一台采用冯诺伊曼结构的计算机EDVAC

(Electronic Discrete Variable Atomatic Computer)

存储程序的概念是指<span style="color:red">将指令以二进制的形式事先输入计算机的主存储器（内存）</span> ，然后按照其在主存储器中的首地址执行程序的第一条指令，以后就按照改程序的规定顺序执行其他指令，直至程序执行结束。

①数据+程序（计算步骤）--> 

②[将信息转换为机器能识别的形式 -- 010101二进制数]输入设备 --> 

[算术运算和逻辑运算]运算器 --> 

[存放数据和程序]存储器 -->

[会用电信号来协调其他部件相互配合工作、从存储器中读取指令并解析、指挥程序运行]控制器 --> 

[将结果转换为人们熟悉的形式]输出设备 -->

①属于软件部件，②③④...属于硬件部件。在计算机系统中，软和硬件在逻辑上是等效的（同一个功能既可以用软件来实现，又可以用硬件来实现）-- 通常情况是用软件实现的成本更低、效率更低；硬件实现的成本更高、效率更高。

冯诺伊曼机特点：1，计算机由五大部件组成，其中输入和输出设备统称为I/O设备；2，指令和数据以同等地位存于存储器，可按址寻访；3，指令和数据都是用二进制表示 -- 很方便用电信号来表示0、1两种状态；4，指令由操作码（指明指令要执行什么样的操作）和地址码（要操作的数据存放在内存的什么地址当中）组成；5，存储程序；6，<span style="color:red">以运算器为中心</span> （输入/输出设备与存储器之间的数据传送通过运算器完成，缺点，导致数据计算的效率降低）；

计算机 == 一个数据加工厂

##### 现代计算机结构

冯诺伊曼结构的优化

<span style="color:red">以存储器为中心</span> 

运算器、控制器的逻辑关系十分紧密，所以在大规模集成电路出现之后，这两个部件通常集成在同一个芯片上的，即CPU = 运算器 + 控制器

主机（CPU （运算器 + 控制器）+ 主存储器） + I/O设备（外设）= 现代计算机结构

主存（内存）、辅存（机械硬盘、固态硬盘等）统称为存储器



### 计算机硬件部件

五个硬件部件 > 主机中的三个硬件部件内部细节以及它们之间如何协调工作的：主存储器、运算器、控制器

##### 主存储器

-- 基本组成：

存放数据的部分 -- 存储体，由一系列存储元件构成，可以存放二进制0/1

Memory Address Register(存储地址寄存器)--MAR 寄存器

Memory Data Register(存储数据寄存器)--MDR 寄存器

寄存器也是用了存放二进制数据的

-- 菜鸟驿站

11-2-xxxx  包裹在货架上按取件号摆放

取件号 -- 告诉 -- 店员（MAR）

店员 -- 取货 -- 柜台 (MDR)

-- 存储体

数据在存储体内按地址存储，存储单元（每个存储单元存放一串二进制代码）、存储字word（存储单元二进制代码组合）、存储字长（存储单元中二进制代码的位数）、存储元（存储二进制的电子元件-应用了电容的原理，每个存储元可以存1bi t）<span style="color:red">（每个地址对应一个存储单元）</span> 

电容可以用来存储电荷，一个电容可以存放一个二进制的bit位

MAR位数反应存储单元的个数、MDR位数 = 存储字长

Eg: MAR = 4位 => 总共由2⁴个存储单元、MDR = 16位 => 每个存储单元可以存放16bit,  一个<span style="color:red">字（word）</span> = 16 bit

一个<span style="color:red">字节（byte）</span>  = 8bit、1B = 1个字节、1b= 1bit

100Mbps =  100M bit/1s = 100/8 MB/1s

##### 运算器

运算器：用于实现算术运算（加减乘除）、逻辑运算（与或非）

-- 基本组成

ACC -- Accumulator：累加器，用于存放操作数，或运算结果

MQ -- Mutiple-Quotient Register：乘商寄存器，在乘、除运算时，用于存放操作数和运算结果

X -- ：通用操作数寄存器，用于存放操作数

ALU -- Arithmetic and Logic Unit：算术逻辑单元，通过内部复杂的电路实现算术运算、逻辑运算

| ...  | 加         | 减         | 乘             | 除           |
| ---- | ---------- | ---------- | -------------- | ------------ |
| ACC  | 被加数、和 | 被减数、差 | 乘积高位       | 被除数、余数 |
| MQ   |            |            | 乘数、乘积低位 | 商           |
| X    | 加数       | 减数       | 被乘数         | 除数         |

##### 控制器

-- 基本组成

CU -- Control Unit：控制单元，分析指令，给出控制信号

IR -- Instruction Register：指令寄存器，存放当前执行的指令

PC -- Program Counter：程序计数器，存放下一条指令的地址，有自动+1的功能

完成一条指令 --> 取指令（PC、IR）、分析指令、执行指令（CU）

##### 计算机工作过程

```c
int a = 2,b = 3,c = 1,y = 0;
void main(){
  y = a * b + c;
}
```

以上为高级语言 --> 编译（翻译成机器能读得懂的语言）装入内存，存储字长为16bit

​                                                |-------> 操作码<------|---------->地址码<-----------|

| 主存地址 | 指令                                                         | 注释                 |
| -------- | ------------------------------------------------------------ | -------------------- |
| 0        | <span style="color:red">000001</span>\|<span style="color:green">0000000101</span> | 取数a至ACC           |
| 1        | <span style="color:red">000100</span>\|<span style="color:green">0000000110</span> | 乘以b得ab，存于ACC中 |
| 2        | <span style="color:red">000011</span>\|<span style="color:green">0000000111</span> | 加c得ab+c，存于ACC中 |
| 3        | <span style="color:red">000010</span>\|<span style="color:green">0000001000</span> | 将ab+c，存于主存单元 |
| 4        | <span style="color:red">000110</span>\|<span style="color:green">0000000000</span> | 停机                 |
| 5        | 000000000000010                                              | 原始数据a=2          |
| 6        | 000000000000011                                              | 原始数据b=3          |
| 7        | 000000000000001                                              | 原始数据c=1          |
| 8        | 000000000000000                                              | 原始数据y=2          |

主存、CPU（运算器、控制器）

![Screen Shot 2022-07-06 at 10.11.59](/Users/hexiaogou/Library/Application Support/typora-user-images/Screen Shot 2022-07-06 at 10.11.59.png)

指令和变量的数据都是存放在主存储器存储体中

***** *

初：（PC）= 0，指向第一条指令的存储地址。然后把存储体中地址为0里面的内容取出来执行

#1： （PC）-> MAR，导致（MAR）= 0。PC存放的内容需要通过地址总线传送到MAR，也就是控制器向主存指明了接下来要访问的时0号地址，同时控制器通过控制总线告诉主存储器说，这次要进行的是读操作

#3：M（MAR）-> MDR，导致（MDR）= <span style="color:red">000001</span>|<span style="color:green">0000000101</span> 。主存储器根据MAR记录的地址信息去存储体找出0号地址对应的二进制数，并且把这些二进制数据放到MDR数据寄存器当中

#4：（MDR）-> IR，导致（IR）= <span style="color:red">000001</span>|<span style="color:green">0000000101</span> 。指令通过数据总线从MDR送传到控制器中的IR

#5：OP（IR）-> CU，指令<span style="color:red">操作码</span> 送到CU，CU分析得知后，这是"<span style="color:red">取数</span> "指令

#6：Ad(IR) -> MAR，指令<span style="color:red">地址码</span> 送到MAR，导致（MAR）= 5

#8：M（MAR）-> MDR，导致（MDR）= 000000000000010 = 2

#9：（MDR）-> ACC，导致（ACC）= 000000000000010 = 2

取指令 （#1～#4）

分析指令（#5）

指向取数指令（#6～#9）

取指令完成之后 PC Auto +1

[注] ()代表寄存器里面的内容，M代表主存储器，-> 表示()指向的数据存放的位置

****

上一条指令取指后 PC Auto +1 （PC）= 1，（ACC）= 2

#1：（PC）-> MAR，导致 （MAR）= 1

#3：M（MAR）-> MDR，导致 （MDR）= <span style="color:red">000100</span>|<span style="color:green">0000000110</span>

#4：（MDR）-> IR，导致 （IR）= <span style="color:red">000100</span>|<span style="color:green">0000000110</span>

#5：OP（IR）-> CU，指令<span style="color:red">操作码</span> 送到CU，CU分析得知后，这是"<span style="color:red">乘法</span> "指令，CU会指挥其他部件完成乘法操作

#6：Ad(IR) -> MAR，指令<span style="color:red">地址码</span> 送到MAR，导致（MAR）= 6

#8：M（MAR）-> MDR，导致（MDR）= 000000000000011 = 3

#9：（MQ）= 3，MDR的值会通过地址总线送到MQ

#10：（ACC）-> X。导致（X）= 2。把a的值从ACC中放到通用寄存器X中，也就是把被乘数放到X中

#11：（MQ）\*（X）-> ACC，由ALU实现乘法运算，导致（ACC）= 6，如果乘积太大，则需要MQ辅助存储，MQ存放结果的低位

取指令 （#1～#4）

分析指令（#5）

指向乘法指令（#6～#11）

指令完成之后 PC Auto +1

****

上一条指令取指后 PC Auto +1 （PC）= 2，（ACC）= 6

#1：（PC）-> MAR，导致 （MAR）= 2

#3：M（MAR）-> MDR，导致 （MDR）=<span style="color:red">000011</span>|<span style="color:green">0000000111</span>

#4：（MDR）-> IR，导致 （IR）= <span style="color:red">000011</span>|<span style="color:green">0000000111</span>

#5：OP（IR）-> CU，指令<span style="color:red">操作码</span> 送到CU，CU分析得知后，这是"<span style="color:red">加法</span> "指令，CU会指挥其他部件完成加法操作

#6：Ad(IR) -> MAR，指令<span style="color:red">地址码</span> 送到MAR，导致（MAR）= 7

#8：M（MAR）-> MDR，导致（MDR）=000000000000001 = 1

#9：（MDR）-> X，导致（X）= 000000000000001 = 1，ACC里面存的是被加数，通用寄存器里存放的是加数，控制单元的CU告诉ALU是一个加法操作。

#10：（ACC）+ （X）-> （ACC），导致（ACC）= 7，由ALU实现加法运算

取指令 （#1～#4）

分析指令（#5）

指向加法指令（#6～#10）

指令完成之后 PC Auto +1

****

上一条指令取指后 PC Auto +1 （PC）= 3，（ACC）= 7

#1：（PC）-> MAR，导致 （MAR）= 3

#3：M（MAR）-> MDR，导致 （MDR）=<span style="color:red">000010</span>|<span style="color:green">0000001000</span>

#4：（MDR）-> IR，导致 （IR）= <span style="color:red">000010</span>|<span style="color:green">0000001000</span>

#5：OP（IR）-> CU，指令<span style="color:red">操作码</span> 送到CU，CU分析得知后，这是"<span style="color:red">存数</span> "指令，把ACC的数据存到地址码指向的地址当中

#6：Ad(IR) -> MAR，指令<span style="color:red">地址码</span> 送到MAR，导致（MAR）= 8

#7：（ACC）-> MDR，导致（MDR）= 7

#8：（MDR）-> 地址单元为8的存储单元，导致y=7，即y = a \* b + c

取指令 （#1～#4）

分析指令（#5）

指向存数指令（#6～#8）

指令完成之后 PC Auto +1

****

上一条指令取指后 PC Auto +1 （PC）= 4

#1：（PC）-> MAR，导致 （MAR）= 4

#3：M（MAR）-> MDR，导致 （MDR）=<span style="color:red">000110</span>|<span style="color:green">0000000000</span>

#4：（MDR）-> IR，导致 （IR）= <span style="color:red">000110</span>|<span style="color:green">0000000000</span>

#5：OP（IR）-> CU，指令<span style="color:red">操作码</span> 送到CU，CU分析得知后，这是"<span style="color:red">停机</span> "指令

#6#7：执行操作系统相关的指令

利用中断机制通知操作系统终止该进程

****

总结：

M（主存中某存储单元）

ACC、MQ、X、MAR、MDR...相应寄存器

M（MAR）：取存储单元中的数据

（ACC）：取相应寄存器中的数据

指令：操作码｜地址码

OP（IR）：取操作码

Ad（IR）：取地址码

取数指令的执行（从主存中指定地址处取数）

```assembly
(PC) --> MAR
M(MAR) --> MDR
(MDR) --> IR
取指令结束(PC) + 1 -> PC
OP(IR) --> CU
分析指令结束
Ad(IR) --> MAR
M(MAR) --> MDR
MDR --> ACC
执行指令结束
```

<span style="color:red">CPU区分指令和数据的依据：指令周期的不同阶段</span> 

【注】现在的计算机通常把MAR、MDR也集成在CPU内



### 计算机多层次结构

传统机器M1（用机器语言的机器，只能识别机器语言），机器语言是二进制的执行命令

<span style="color:red">0000001</span>|<span style="color:green">0000000101</span>  （取数指令）

<span style="color:red">0000100</span>|<span style="color:green">0000000110</span>  （乘法指令）

微程序机器M0（微指令、微操作系统），由硬件直接执行微指令，微指令1、微指令3、微指令7...

微程序机器M0是对传统机器M1的分解

符号式程序设计语言 -- 汇编语言

虚拟机器M2（汇编语言机器）LOAD 5    MUL 6 ....，虚拟的原因是，任何一台机器都不可能直接识别并执行汇编语言，必须通过汇编程序翻译机器语言执行，每条汇编语言指令和机器指令是一一对应的，汇编语言也是一种低级的语言。同时虚拟机器M2（操作系统机器）向上提供广义指令（系统调用）

虚拟机器M3（高级语言机器）y = a \* b + c，用<span style="color:red">编译程序翻译</span> 成汇编语言程序

M0~M1是硬件部分、>=M2是软件部分。下层是上层的基础、上层是下层的扩展

##### 三种级别语言

高级语言：C++、Java y = a \* b + c（源程序）--> 

编译程序（编译器）翻译 --> 

汇编语言（助记符）LOAD 5  MUL 6... --> 

汇编程序（汇编器）--> 

机器语言（二进制代码） <span style="color:red">0000001</span>|<span style="color:green">0000000101</span> 



很多脚本语言如：Javascript、Python、Shell

高级语言：C++、Java y = a \* b + c（源程序）--> 

解释程序（解释器）-->

机器语言（二进制代码） <span style="color:red">0000001</span>|<span style="color:green">0000000101</span> 



编译程序与解释程序的区别：

编译程序：将高级语言编写的源程序全部语句一次性全部翻译成机器语言程序，而后再执行机器语言程序（只需翻译一次），对应语言为编译型语言

解释程序：将源程序的一条语句翻译成对应机器语言的语句，并立即执行，紧接着再翻译下一句（每次执行都要翻译），对应语言为解释型语言

编译型执行效率比解释型效率高些

【注】编译、汇编、解释程序可统称为“翻译程序”

##### 体系结构vs组成原理

计算机体系结构 vs 计算机组成原理

计算机体系结构 -- 机器语言程序员所见到的计算机系统的属性概念性的结构与功能特性（指令系统、数据类型、寻址技术、I/O机理） -- 有无乘法指令，即如何设计硬件与软件之间的接口

计算机组成原理 -- 实现计算机体系结构所体现的属性，对程序员“透明-不可见”（具体指令的实现）-- 如何实现乘法指令，即怎么用硬件来实现所定义的接口

【注】此处透明 --看不见、某事公开透明 -- 看得见

《海贼王》透明果实能力者



### 计算机性能指标

##### 存储器性能指标

度量存储器的指标 -- 存储器的容量

MAR位数反映存储单元个数（最多支持多少个）

MDR 位数 = 存储字长 = 每个存储单元大小

<span style="color:red">总容量 = 存储单元个数 x 存储字长 bit    1Byte = 8 bit</span> 

<span style="color:red">总容量 = 存储单元个数 x 存储字长/8 Byte</span> 

Eg：MAR为32位，MDR 为8 位，则总容量 = 2³² x 2⁸ bit = 2⁴⁰  bit =  2³² Byte =  4GB 

(2¹⁰ B = 1KB 、2²⁰ B = 1MB、2³⁰ B = 1GB、2⁴⁰ B = 1TB)

n个进制位能表示多少种不同的状态？ 2^n种

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 2    | 4    | 8    | 16   | 32   | 64   | 128  | 256  | 512  | 1024 |

| 11   | 12   | 13   | 14    | 15    | 16    |
| ---- | ---- | ---- | ----- | ----- | ----- |
| 2048 | 4096 | 8192 | 16834 | 32768 | 65536 |

##### CPU性能指标

CPU主频：CPU内数字脉冲振荡的频率

![Screen Shot 2022-07-07 at 10.32.12](/Users/hexiaogou/Library/Application Support/typora-user-images/Screen Shot 2022-07-07 at 10.32.12.png)

一个波峰就是一个数字脉冲信号 -- 指挥CPU一步步工作的节奏

<span style="color:red">CPU时钟周期</span> ：一个脉冲信号的时间（单位微秒、纳秒） => CPU 主频 （时钟频率）= 1/CPU时钟周期 （单位为赫兹HZ）

<span style="color:red">CPI</span> （Clock cycle Per Instruction ）：执行一条指令所需的时钟周期数，考虑平均的情况

同一个CPU 执行不同的指令CPI不同，甚至相同的指令，CPI也有可能发生变化

<span style="color:red">执行一条指令的耗时</span>  = CPI x CPU时钟周期

Eg: 某CPU主频为1000Hz，某程序包含100条指令，平均来看指令CPI = 3。该程序在该CPU上执行需要多久？

100 x 3/1000 = 0.3s

<span style="color:red">CPU执行时间</span> （整个程序耗时） =  CPU时钟周期数/主频 = （指令条数 x CPI）/ 主频

<span style="color:red">IPS</span> （Instruction Per Second）：每秒执行多少条指令，IPS = 主频/平均CPI （主频反映的是每秒钟有多少个数字脉冲，CPI翻反映的是执行一条指令所需的时钟周期数） -- KIPS(千)、MIPS(百万)

<span style="color:red">FLOPS</span> (Float - point Operations Per Second)：每秒执行多少次浮点运算 -- KFLOPS、MFLOPS、GFLOPS、TFLOPS

[注]此处K、M、G、T为数量单位

K = Kilo = 千 = 10^3

M = Million = 百万 = 10^6

G = Giga = 十亿 = 10^9

T = Tera = 万亿 = 10^12

##### 系统整体性能指标

--静态指标

数据通路带宽：数据总线一次所能并行传送信息的位数--二进制信息位（CPU、内存、I/O设备，各个硬件部件通过数据总线传输数据）

吞吐量：指系统在单位时间内处理请求（一条指令，一个完整的程序运行）的数量。它取决于信息能多快地输入内存，CPU能多快地执行指令，数据能多快地从内存取出或存入，以及所得的结果能多快地从内存送给一台外部设备。这些步骤的每一步都关系到主存，因此吞吐量主要取决于主存的存储周期。

响应时间：指用户向计算机发送一个请求，到系统对该请求作出响应并获得它所需要结果的等待时间

静态指标很难反映一个计算机系统的综合能力

--动态测试

<span style="color:red">基准程序</span>（跑分软件）是用来测量计算机处理速度的一种使用程序，以便被测量的计算机性能可以与运行相同程序的其他计算机性能进行比较



 问题1:主频高的CPU一定比主频低的CPU快么？不一定，如两个CPU，A主频2GHz，平均CPI = 10；B主频为1GHz，平均CPI=1 => 

对于B而言：

CPU主频 = 1/CPU时钟周期 = 1GHz 

CPU时钟周期 = 1/1G s

CPI = 执行一条指令所需的时钟周期数 = 1 

即B 1s内能执行1G的时钟周期 = 1G的指令

对于A而言：

CPU主频 = 1/CPU时钟周期 = 2GHz 

CPU时钟周期 = 1/2G s

CPI = 执行一条指令所需的时钟周期数 = 10

即A 1s内能执行2G的时钟周期 = 2/10G的指指令 = 0.2G的指令

1G = 10⁹



问题2:若A、B两个CPU平均CPI相同，那么A 一定更快么？假设CPI为x

对于B而言：即B 1s内能执行1G的时钟周期 = 1G/x的指令

对于A而言：即A 1s内能执行2G的时钟周期 = 2G/x的指令

乍一看 2G/x > 1G/x

但是也不一定，还要看指令系统，如A不支持乘法指令，只能用多次加法实现乘法，而B支持乘法指令。



问题3：基准程序执行地越快说明机器性能越好吗？

基准程序中语句存在频度差异，运行结果也不能完全说明问题。
